"""
Type stub file for job_processing_pb2.py generated by protobuf compiler.
This helps static type checkers like Pyright understand the generated code.
"""

from typing import Any, ClassVar, Mapping, Optional, Iterable
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
from google.protobuf import timestamp_pb2 as _timestamp_pb2

# Enums
class JobStatus(int):
    JOB_STATUS_PENDING: ClassVar[int]
    JOB_STATUS_PROCESSING: ClassVar[int]
    JOB_STATUS_COMPLETED: ClassVar[int]
    JOB_STATUS_FAILED: ClassVar[int]
    JOB_STATUS_CANCELLED: ClassVar[int]
    JOB_STATUS_QUEUED: ClassVar[int]

class ServiceStatus(int):
    SERVICE_STATUS_HEALTHY: ClassVar[int]
    SERVICE_STATUS_DEGRADED: ClassVar[int]
    SERVICE_STATUS_UNHEALTHY: ClassVar[int]

class BatchStatus(int):
    BATCH_STATUS_PENDING: ClassVar[int]
    BATCH_STATUS_PROCESSING: ClassVar[int]
    BATCH_STATUS_COMPLETED: ClassVar[int]
    BATCH_STATUS_FAILED: ClassVar[int]
    BATCH_STATUS_CANCELLED: ClassVar[int]

# Message classes
class JobSubmissionRequest(_message.Message):
    job_id: str
    jd_url: str
    resume_uri: str
    model_provider: str
    model_name: str
    user_id: str
    priority: int
    trace_id: str
    options: Mapping[str, str]
    def __init__(self, *, job_id: str = ..., jd_url: str = ..., resume_uri: str = ...,
                 model_provider: str = ..., model_name: str = ..., user_id: str = ...,
                 priority: int = ..., trace_id: str = ..., options: Optional[Mapping[str, str]] = ...) -> None: ...

class JobSubmissionResponse(_message.Message):
    job_id: str
    status: JobStatus
    message: str
    submitted_at: _timestamp_pb2.Timestamp
    queue_position: int
    estimated_completion_ms: int
    def __init__(self, *, job_id: str = ..., status: JobStatus = ..., message: str = ...,
                 submitted_at: Optional[_timestamp_pb2.Timestamp] = ..., queue_position: int = ...,
                 estimated_completion_ms: int = ...) -> None: ...

class JobUpdateRequest(_message.Message):
    job_ids: Iterable[str]
    user_id: str
    include_content: bool
    def __init__(self, *, job_ids: Optional[Iterable[str]] = ..., user_id: str = ...,
                 include_content: bool = ...) -> None: ...

class JobUpdateResponse(_message.Message):
    job_id: str
    status: JobStatus
    updated_at: _timestamp_pb2.Timestamp
    message: str
    content_chunk: str
    is_partial: bool
    metadata: Mapping[str, str]
    def __init__(self, *, job_id: str = ..., status: JobStatus = ...,
                 updated_at: Optional[_timestamp_pb2.Timestamp] = ..., message: str = ...,
                 content_chunk: str = ..., is_partial: bool = ...,
                 metadata: Optional[Mapping[str, str]] = ...) -> None: ...

class BatchJobRequest(_message.Message):
    batch_id: str
    jobs: Iterable[JobSubmissionRequest]
    user_id: str
    max_parallel: int
    def __init__(self, *, batch_id: str = ..., jobs: Optional[Iterable[JobSubmissionRequest]] = ...,
                 user_id: str = ..., max_parallel: int = ...) -> None: ...

class BatchJobResponse(_message.Message):
    batch_id: str
    total_jobs: int
    completed_jobs: int
    failed_jobs: int
    job_updates: Iterable[JobUpdateResponse]
    batch_status: BatchStatus
    def __init__(self, *, batch_id: str = ..., total_jobs: int = ..., completed_jobs: int = ...,
                 failed_jobs: int = ..., job_updates: Optional[Iterable[JobUpdateResponse]] = ...,
                 batch_status: BatchStatus = ...) -> None: ...

class JobResultRequest(_message.Message):
    job_id: str
    user_id: str
    def __init__(self, *, job_id: str = ..., user_id: str = ...) -> None: ...

class GeneratedContent(_message.Message):
    content_type: str
    content: str
    word_count: int
    quality_score: float
    def __init__(self, *, content_type: str = ..., content: str = ..., word_count: int = ...,
                 quality_score: float = ...) -> None: ...

class ProcessingMetadata(_message.Message):
    model_used: str
    cost_usd: float
    processing_time_ms: int
    cached: bool
    tokens_used: int
    def __init__(self, *, model_used: str = ..., cost_usd: float = ...,
                 processing_time_ms: int = ..., cached: bool = ..., tokens_used: int = ...) -> None: ...

class JobResultResponse(_message.Message):
    job_id: str
    status: JobStatus
    content: GeneratedContent
    metadata: ProcessingMetadata
    created_at: _timestamp_pb2.Timestamp
    def __init__(self, *, job_id: str = ..., status: JobStatus = ...,
                 content: Optional[GeneratedContent] = ..., metadata: Optional[ProcessingMetadata] = ...,
                 created_at: Optional[_timestamp_pb2.Timestamp] = ...) -> None: ...

class HealthRequest(_message.Message):
    service_id: str
    def __init__(self, *, service_id: str = ...) -> None: ...

class ResourceUsage(_message.Message):
    cpu_percent: float
    memory_percent: float
    memory_used_mb: float
    active_connections: int
    thread_count: int
    def __init__(self, *, cpu_percent: float = ..., memory_percent: float = ...,
                 memory_used_mb: float = ..., active_connections: int = ...,
                 thread_count: int = ...) -> None: ...

class HealthResponse(_message.Message):
    status: ServiceStatus
    version: str
    timestamp: _timestamp_pb2.Timestamp
    dependencies: Mapping[str, int]
    resource_usage: ResourceUsage
    def __init__(self, *, status: ServiceStatus = ..., version: str = ...,
                 timestamp: Optional[_timestamp_pb2.Timestamp] = ...,
                 dependencies: Optional[Mapping[str, int]] = ...,
                 resource_usage: Optional[ResourceUsage] = ...) -> None: ...

class CancelJobRequest(_message.Message):
    job_id: str
    user_id: str
    reason: str
    def __init__(self, *, job_id: str = ..., user_id: str = ..., reason: str = ...) -> None: ...

class CancelJobResponse(_message.Message):
    job_id: str
    cancelled: bool
    message: str
    final_status: JobStatus
    def __init__(self, *, job_id: str = ..., cancelled: bool = ..., message: str = ...,
                 final_status: JobStatus = ...) -> None: ...

class MetricsRequest(_message.Message):
    service_id: str
    start_time: _timestamp_pb2.Timestamp
    end_time: _timestamp_pb2.Timestamp
    def __init__(self, *, service_id: str = ...,
                 start_time: Optional[_timestamp_pb2.Timestamp] = ...,
                 end_time: Optional[_timestamp_pb2.Timestamp] = ...) -> None: ...

class PerformanceStats(_message.Message):
    avg_processing_time_ms: float
    p95_processing_time_ms: float
    p99_processing_time_ms: float
    total_requests: int
    successful_requests: int
    failed_requests: int
    throughput_per_second: float
    def __init__(self, *, avg_processing_time_ms: float = ..., p95_processing_time_ms: float = ...,
                 p99_processing_time_ms: float = ..., total_requests: int = ...,
                 successful_requests: int = ..., failed_requests: int = ...,
                 throughput_per_second: float = ...) -> None: ...

class QueueStats(_message.Message):
    pending_jobs: int
    processing_jobs: int
    total_queued: int
    avg_wait_time_ms: float
    def __init__(self, *, pending_jobs: int = ..., processing_jobs: int = ...,
                 total_queued: int = ..., avg_wait_time_ms: float = ...) -> None: ...

class ProcessingMetrics(_message.Message):
    service_name: str
    timestamp: _timestamp_pb2.Timestamp
    resource_usage: ResourceUsage
    performance: PerformanceStats
    queue_stats: QueueStats
    custom_metrics: Mapping[str, float]
    def __init__(self, *, service_name: str = ...,
                 timestamp: Optional[_timestamp_pb2.Timestamp] = ...,
                 resource_usage: Optional[ResourceUsage] = ...,
                 performance: Optional[PerformanceStats] = ...,
                 queue_stats: Optional[QueueStats] = ...,
                 custom_metrics: Optional[Mapping[str, float]] = ...) -> None: ...

class AggregatedStats(_message.Message):
    total_jobs_processed: int
    total_cost_usd: float
    avg_quality_score: float
    cache_hit_rate: float
    total_processing_time_ms: int
    def __init__(self, *, total_jobs_processed: int = ..., total_cost_usd: float = ...,
                 avg_quality_score: float = ..., cache_hit_rate: float = ...,
                 total_processing_time_ms: int = ...) -> None: ...

class MetricsResponse(_message.Message):
    metrics: Iterable[ProcessingMetrics]
    aggregated: AggregatedStats
    def __init__(self, *, metrics: Optional[Iterable[ProcessingMetrics]] = ...,
                 aggregated: Optional[AggregatedStats] = ...) -> None: ...

class JobStatusUpdate(_message.Message):
    job_id: str
    status: JobStatus
    message: str
    updated_at: _timestamp_pb2.Timestamp
    metadata: Mapping[str, str]
    def __init__(self, *, job_id: str = ..., status: JobStatus = ..., message: str = ...,
                 updated_at: Optional[_timestamp_pb2.Timestamp] = ...,
                 metadata: Optional[Mapping[str, str]] = ...) -> None: ...

class StatusUpdateAck(_message.Message):
    acknowledged: bool
    message: str
    def __init__(self, *, acknowledged: bool = ..., message: str = ...) -> None: ...

/**
 * Progressive Web App (PWA) Module
 * Handles service worker registration, app install prompts, and offline functionality
 */

export default class PWAModule {
    constructor() {
        this.initialized = false;
        this.registration = null;
        this.deferredPrompt = null;
        this.isOnline = navigator.onLine;
        this.isInstalled = false;
        this.updateAvailable = false;
        this.offlineQueue = [];
        
        // Connection quality tracking
        this.connectionInfo = {
            effectiveType: 'unknown',
            downlink: 0,
            rtt: 0,
            saveData: false
        };
    }
    
    async init() {
        if (this.initialized) return;
        
        console.log('🚀 Initializing PWA Module...');
        
        // Check if running as installed PWA
        this.checkInstallStatus();
        
        // Register service worker
        await this.registerServiceWorker();
        
        // Setup install prompt handling
        this.setupInstallPrompt();
        
        // Setup offline/online detection
        this.setupConnectionDetection();
        
        // Setup background sync
        this.setupBackgroundSync();
        
        // Setup push notifications
        await this.setupPushNotifications();
        
        // Setup periodic updates
        this.setupPeriodicUpdates();
        
        // Setup share target handling
        this.setupShareTargetHandling();
        
        // Monitor connection quality
        this.monitorConnectionQuality();
        
        this.initialized = true;
        console.log('✅ PWA Module Ready');
        
        // Dispatch PWA ready event
        window.dispatchEvent(new CustomEvent('pwa:ready', {
            detail: { 
                installed: this.isInstalled,
                online: this.isOnline,
                registration: this.registration 
            }
        }));
    }
    
    checkInstallStatus() {
        // Check various indicators for PWA installation
        this.isInstalled = (
            window.navigator.standalone === true || // iOS Safari
            window.matchMedia('(display-mode: standalone)').matches || // Standard
            window.matchMedia('(display-mode: fullscreen)').matches ||
            window.matchMedia('(display-mode: minimal-ui)').matches ||
            document.referrer.includes('android-app://') // Android TWA
        );
        
        console.log('PWA Install Status:', this.isInstalled);
        
        // Add CSS class for styling
        if (this.isInstalled) {
            document.documentElement.classList.add('pwa-installed');
        }
    }
    
    async registerServiceWorker() {
        if (!('serviceWorker' in navigator)) {
            console.warn('Service Workers not supported');
            return;
        }
        
        try {
            this.registration = await navigator.serviceWorker.register('/sw.js', {
                scope: '/',
                updateViaCache: 'none'
            });\n            \n            console.log('SW: Service Worker registered successfully');\n            \n            // Listen for service worker updates\n            this.registration.addEventListener('updatefound', () => {\n                const newWorker = this.registration.installing;\n                console.log('SW: New service worker found, installing...');\n                \n                newWorker.addEventListener('statechange', () => {\n                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n                        console.log('SW: New service worker installed, update available');\n                        this.updateAvailable = true;\n                        this.showUpdateNotification();\n                    }\n                });\n            });\n            \n            // Listen for service worker messages\n            navigator.serviceWorker.addEventListener('message', this.handleServiceWorkerMessage.bind(this));\n            \n            // Check for existing update\n            if (this.registration.waiting) {\n                this.updateAvailable = true;\n                this.showUpdateNotification();\n            }\n            \n        } catch (error) {\n            console.error('SW: Service Worker registration failed:', error);\n        }\n    }\n    \n    setupInstallPrompt() {\n        // Listen for beforeinstallprompt event\n        window.addEventListener('beforeinstallprompt', (event) => {\n            console.log('PWA: Install prompt available');\n            \n            // Prevent default prompt\n            event.preventDefault();\n            \n            // Store the event for later use\n            this.deferredPrompt = event;\n            \n            // Show custom install button/banner\n            this.showInstallPrompt();\n        });\n        \n        // Listen for app installed event\n        window.addEventListener('appinstalled', () => {\n            console.log('PWA: App installed successfully');\n            this.isInstalled = true;\n            document.documentElement.classList.add('pwa-installed');\n            \n            // Hide install prompt\n            this.hideInstallPrompt();\n            \n            // Show success notification\n            this.showNotification('App installed successfully! 🎉', 'success');\n            \n            // Track installation\n            this.trackEvent('pwa_installed');\n        });\n    }\n    \n    setupConnectionDetection() {\n        // Listen for online/offline events\n        window.addEventListener('online', () => {\n            console.log('PWA: Back online');\n            this.isOnline = true;\n            this.handleOnlineStateChange(true);\n        });\n        \n        window.addEventListener('offline', () => {\n            console.log('PWA: Gone offline');\n            this.isOnline = false;\n            this.handleOnlineStateChange(false);\n        });\n        \n        // Initial state\n        this.handleOnlineStateChange(this.isOnline);\n    }\n    \n    setupBackgroundSync() {\n        if (!('serviceWorker' in navigator) || !('sync' in window.ServiceWorkerRegistration.prototype)) {\n            console.warn('Background Sync not supported');\n            return;\n        }\n        \n        // Register background sync for offline job submissions\n        this.setupJobSubmissionSync();\n    }\n    \n    async setupPushNotifications() {\n        if (!('Notification' in window) || !('PushManager' in window)) {\n            console.warn('Push notifications not supported');\n            return;\n        }\n        \n        // Check current permission status\n        const permission = await Notification.requestPermission();\n        console.log('Notification permission:', permission);\n        \n        if (permission === 'granted' && this.registration) {\n            try {\n                // Subscribe to push notifications\n                const subscription = await this.registration.pushManager.subscribe({\n                    userVisibleOnly: true,\n                    applicationServerKey: this.urlBase64ToUint8Array(this.getVapidPublicKey())\n                });\n                \n                console.log('Push subscription created:', subscription);\n                \n                // Send subscription to server\n                await this.sendSubscriptionToServer(subscription);\n                \n            } catch (error) {\n                console.warn('Failed to setup push notifications:', error);\n            }\n        }\n    }\n    \n    setupPeriodicUpdates() {\n        if (!('serviceWorker' in navigator) || !('periodicSync' in window.ServiceWorkerRegistration.prototype)) {\n            console.warn('Periodic Background Sync not supported');\n            return;\n        }\n        \n        // Request periodic sync for dashboard updates\n        navigator.serviceWorker.ready.then(registration => {\n            return registration.periodicSync.register('update-dashboard', {\n                minInterval: 12 * 60 * 60 * 1000, // 12 hours\n            });\n        }).then(() => {\n            console.log('Periodic sync registered');\n        }).catch(error => {\n            console.warn('Periodic sync registration failed:', error);\n        });\n    }\n    \n    setupShareTargetHandling() {\n        // Handle shared content from URL parameters\n        const urlParams = new URLSearchParams(window.location.search);\n        if (urlParams.get('shared') === 'true') {\n            this.handleSharedContent();\n        }\n    }\n    \n    monitorConnectionQuality() {\n        if ('connection' in navigator) {\n            const connection = navigator.connection;\n            \n            this.connectionInfo = {\n                effectiveType: connection.effectiveType || 'unknown',\n                downlink: connection.downlink || 0,\n                rtt: connection.rtt || 0,\n                saveData: connection.saveData || false\n            };\n            \n            console.log('Connection info:', this.connectionInfo);\n            \n            // Listen for connection changes\n            connection.addEventListener('change', () => {\n                this.connectionInfo = {\n                    effectiveType: connection.effectiveType,\n                    downlink: connection.downlink,\n                    rtt: connection.rtt,\n                    saveData: connection.saveData\n                };\n                \n                this.handleConnectionQualityChange();\n            });\n        }\n    }\n    \n    // Public Methods\n    \n    async installApp() {\n        if (!this.deferredPrompt) {\n            console.warn('Install prompt not available');\n            return false;\n        }\n        \n        try {\n            // Show the install prompt\n            this.deferredPrompt.prompt();\n            \n            // Wait for user response\n            const { outcome } = await this.deferredPrompt.userChoice;\n            console.log('Install prompt outcome:', outcome);\n            \n            // Clean up\n            this.deferredPrompt = null;\n            \n            if (outcome === 'accepted') {\n                this.trackEvent('pwa_install_accepted');\n                return true;\n            } else {\n                this.trackEvent('pwa_install_dismissed');\n                return false;\n            }\n            \n        } catch (error) {\n            console.error('Install prompt failed:', error);\n            return false;\n        }\n    }\n    \n    async updateApp() {\n        if (!this.updateAvailable || !this.registration) {\n            console.warn('No update available');\n            return;\n        }\n        \n        const waitingWorker = this.registration.waiting;\n        if (waitingWorker) {\n            // Tell the waiting worker to skip waiting\n            waitingWorker.postMessage({ type: 'SKIP_WAITING' });\n            \n            // Reload the page to use the new service worker\n            window.location.reload();\n        }\n    }\n    \n    async shareContent(data) {\n        if (!navigator.share) {\n            console.warn('Web Share API not supported');\n            return false;\n        }\n        \n        try {\n            await navigator.share(data);\n            console.log('Content shared successfully');\n            this.trackEvent('content_shared', { type: data.title });\n            return true;\n        } catch (error) {\n            if (error.name !== 'AbortError') {\n                console.error('Share failed:', error);\n            }\n            return false;\n        }\n    }\n    \n    async getCacheInfo() {\n        if (!this.registration) return null;\n        \n        return new Promise((resolve) => {\n            const messageChannel = new MessageChannel();\n            messageChannel.port1.onmessage = (event) => {\n                resolve(event.data);\n            };\n            \n            this.registration.active.postMessage(\n                { type: 'GET_CACHE_INFO' },\n                [messageChannel.port2]\n            );\n        });\n    }\n    \n    async clearCache(cacheType = null) {\n        if (!this.registration) return;\n        \n        this.registration.active.postMessage({\n            type: 'CLEAR_CACHE',\n            payload: { cacheType }\n        });\n        \n        this.showNotification('Cache cleared successfully', 'success');\n    }\n    \n    queueOfflineAction(action, data) {\n        this.offlineQueue.push({ action, data, timestamp: Date.now() });\n        console.log('Action queued for offline:', action);\n        \n        // Try to sync immediately if online\n        if (this.isOnline) {\n            this.processOfflineQueue();\n        }\n    }\n    \n    // Event Handlers\n    \n    handleServiceWorkerMessage(event) {\n        const { type, payload } = event.data;\n        \n        switch (type) {\n            case 'CONTENT_UPDATED':\n                this.handleContentUpdate(payload);\n                break;\n            case 'CACHE_SECONDARY_ASSETS':\n                this.cacheSecondaryAssets(payload.assets);\n                break;\n            default:\n                console.log('SW Message:', type, payload);\n        }\n    }\n    \n    handleOnlineStateChange(isOnline) {\n        const indicator = document.getElementById('connection-indicator');\n        \n        if (isOnline) {\n            document.body.classList.remove('offline');\n            document.body.classList.add('online');\n            \n            if (indicator) {\n                indicator.textContent = 'Online';\n                indicator.className = 'connection-indicator online';\n            }\n            \n            // Process offline queue\n            this.processOfflineQueue();\n            \n            // Show back online notification\n            if (!this.isOnline) { // Was offline before\n                this.showNotification('Back online! 🌐', 'success', 3000);\n            }\n        } else {\n            document.body.classList.remove('online');\n            document.body.classList.add('offline');\n            \n            if (indicator) {\n                indicator.textContent = 'Offline';\n                indicator.className = 'connection-indicator offline';\n            }\n            \n            // Show offline notification\n            this.showNotification('You\\'re offline. Some features may be limited.', 'warning', 5000);\n        }\n        \n        // Dispatch connection change event\n        window.dispatchEvent(new CustomEvent('pwa:connection-change', {\n            detail: { online: isOnline, connectionInfo: this.connectionInfo }\n        }));\n    }\n    \n    handleConnectionQualityChange() {\n        console.log('Connection quality changed:', this.connectionInfo);\n        \n        // Adapt behavior based on connection quality\n        if (this.connectionInfo.saveData || this.connectionInfo.effectiveType === 'slow-2g') {\n            // Enable data saver mode\n            document.body.classList.add('data-saver-mode');\n            console.log('Data saver mode enabled');\n        } else {\n            document.body.classList.remove('data-saver-mode');\n        }\n        \n        // Dispatch connection quality event\n        window.dispatchEvent(new CustomEvent('pwa:connection-quality-change', {\n            detail: this.connectionInfo\n        }));\n    }\n    \n    handleContentUpdate(payload) {\n        console.log('Content updated:', payload.url);\n        \n        // Show update notification\n        this.showNotification('Page content updated', 'info', 3000);\n        \n        // Optionally reload specific content\n        this.reloadPageContent(payload.url);\n    }\n    \n    async handleSharedContent() {\n        try {\n            // Get shared content from IndexedDB\n            const db = await this.openDB();\n            const transaction = db.transaction(['shared_content'], 'readonly');\n            const store = transaction.objectStore('shared_content');\n            const sharedItems = await store.getAll();\n            \n            if (sharedItems.length > 0) {\n                const latestItem = sharedItems[sharedItems.length - 1];\n                \n                // Process shared content\n                this.processSharedContent(latestItem);\n                \n                // Clean up processed items\n                const deleteTransaction = db.transaction(['shared_content'], 'readwrite');\n                const deleteStore = deleteTransaction.objectStore(['shared_content']);\n                await deleteStore.clear();\n            }\n            \n        } catch (error) {\n            console.error('Failed to handle shared content:', error);\n        }\n    }\n    \n    // UI Methods\n    \n    showInstallPrompt() {\n        const existingPrompt = document.getElementById('pwa-install-prompt');\n        if (existingPrompt) return;\n        \n        const prompt = document.createElement('div');\n        prompt.id = 'pwa-install-prompt';\n        prompt.className = 'pwa-install-prompt';\n        prompt.innerHTML = `\n            <div class=\"pwa-prompt-content\">\n                <div class=\"pwa-prompt-icon\">📱</div>\n                <div class=\"pwa-prompt-text\">\n                    <h3>Install HuskyApply</h3>\n                    <p>Get the full app experience with offline access and faster loading</p>\n                </div>\n                <div class=\"pwa-prompt-actions\">\n                    <button class=\"btn-secondary\" data-action=\"dismiss\">Not now</button>\n                    <button class=\"btn-primary\" data-action=\"install\">Install App</button>\n                </div>\n            </div>\n            <button class=\"pwa-prompt-close\" data-action=\"close\">×</button>\n        `;\n        \n        // Add event listeners\n        prompt.addEventListener('click', (e) => {\n            const action = e.target.dataset.action;\n            if (action === 'install') {\n                this.installApp();\n            }\n            if (action === 'dismiss' || action === 'close') {\n                this.hideInstallPrompt();\n            }\n        });\n        \n        document.body.appendChild(prompt);\n        \n        // Animate in\n        setTimeout(() => prompt.classList.add('visible'), 100);\n    }\n    \n    hideInstallPrompt() {\n        const prompt = document.getElementById('pwa-install-prompt');\n        if (prompt) {\n            prompt.classList.remove('visible');\n            setTimeout(() => prompt.remove(), 300);\n        }\n    }\n    \n    showUpdateNotification() {\n        const notification = this.showNotification(\n            'A new version is available!',\n            'info',\n            0,\n            [{\n                id: 'update',\n                text: 'Update Now',\n                primary: true,\n                handler: () => this.updateApp()\n            }, {\n                id: 'dismiss',\n                text: 'Later',\n                handler: () => console.log('Update dismissed')\n            }]\n        );\n        \n        return notification;\n    }\n    \n    createConnectionIndicator() {\n        const indicator = document.createElement('div');\n        indicator.id = 'connection-indicator';\n        indicator.className = `connection-indicator ${this.isOnline ? 'online' : 'offline'}`;\n        indicator.textContent = this.isOnline ? 'Online' : 'Offline';\n        \n        // Style the indicator\n        indicator.style.cssText = `\n            position: fixed;\n            top: 60px;\n            left: 1rem;\n            padding: 0.5rem 1rem;\n            border-radius: 1rem;\n            font-size: 0.75rem;\n            font-weight: 600;\n            z-index: 1000;\n            transition: all 0.3s ease;\n            backdrop-filter: blur(10px);\n        `;\n        \n        document.body.appendChild(indicator);\n        return indicator;\n    }\n    \n    // Helper Methods\n    \n    async processOfflineQueue() {\n        if (this.offlineQueue.length === 0) return;\n        \n        console.log(`Processing ${this.offlineQueue.length} offline actions`);\n        \n        const processedActions = [];\n        \n        for (const queuedAction of this.offlineQueue) {\n            try {\n                await this.executeQueuedAction(queuedAction);\n                processedActions.push(queuedAction);\n            } catch (error) {\n                console.error('Failed to process queued action:', error);\n            }\n        }\n        \n        // Remove processed actions from queue\n        this.offlineQueue = this.offlineQueue.filter(action => \n            !processedActions.includes(action)\n        );\n        \n        if (processedActions.length > 0) {\n            this.showNotification(\n                `Synced ${processedActions.length} offline actions`,\n                'success',\n                3000\n            );\n        }\n    }\n    \n    async executeQueuedAction(queuedAction) {\n        const { action, data } = queuedAction;\n        \n        switch (action) {\n            case 'submit-job':\n                return await this.submitJob(data);\n            case 'save-template':\n                return await this.saveTemplate(data);\n            case 'update-settings':\n                return await this.updateSettings(data);\n            default:\n                console.warn('Unknown queued action:', action);\n        }\n    }\n    \n    setupJobSubmissionSync() {\n        // Register for background sync when jobs are submitted offline\n        if (this.registration && 'sync' in this.registration) {\n            window.addEventListener('job-submit-offline', () => {\n                this.registration.sync.register('job-submission');\n            });\n        }\n    }\n    \n    async cacheSecondaryAssets(assets) {\n        if (!this.registration) return;\n        \n        try {\n            const cache = await caches.open('huskyapply-static-v2.1');\n            \n            for (const asset of assets) {\n                try {\n                    await cache.add(asset);\n                    console.log('Cached secondary asset:', asset);\n                } catch (error) {\n                    console.warn('Failed to cache asset:', asset, error.message);\n                }\n            }\n        } catch (error) {\n            console.error('Failed to cache secondary assets:', error);\n        }\n    }\n    \n    processSharedContent(sharedContent) {\n        console.log('Processing shared content:', sharedContent);\n        \n        // Fill in job description URL if shared\n        const jobUrlInput = document.getElementById('jd-url');\n        if (jobUrlInput && sharedContent.url) {\n            jobUrlInput.value = sharedContent.url;\n            \n            // Trigger input event\n            jobUrlInput.dispatchEvent(new Event('input', { bubbles: true }));\n        }\n        \n        // Show notification\n        this.showNotification('Shared content loaded', 'success', 3000);\n    }\n    \n    reloadPageContent(url) {\n        // Reload specific page content without full page refresh\n        const event = new CustomEvent('content-reload-needed', {\n            detail: { url }\n        });\n        window.dispatchEvent(event);\n    }\n    \n    urlBase64ToUint8Array(base64String) {\n        const padding = '='.repeat((4 - base64String.length % 4) % 4);\n        const base64 = (base64String + padding)\n            .replace(/-/g, '+')\n            .replace(/_/g, '/');\n        \n        const rawData = window.atob(base64);\n        const outputArray = new Uint8Array(rawData.length);\n        \n        for (let i = 0; i < rawData.length; ++i) {\n            outputArray[i] = rawData.charCodeAt(i);\n        }\n        return outputArray;\n    }\n    \n    getVapidPublicKey() {\n        // This should be your VAPID public key from the server\n        return 'BEL-example-key-replace-with-actual-vapid-public-key';\n    }\n    \n    async sendSubscriptionToServer(subscription) {\n        try {\n            const response = await fetch('/api/v1/push/subscribe', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${localStorage.getItem('authToken')}`\n                },\n                body: JSON.stringify(subscription)\n            });\n            \n            if (response.ok) {\n                console.log('Push subscription sent to server');\n            }\n        } catch (error) {\n            console.error('Failed to send subscription to server:', error);\n        }\n    }\n    \n    openDB() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open('HuskyApplyDB', 2);\n            \n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => resolve(request.result);\n            \n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                \n                if (!db.objectStoreNames.contains('shared_content')) {\n                    const store = db.createObjectStore('shared_content', { \n                        keyPath: 'id', \n                        autoIncrement: true \n                    });\n                    store.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n            };\n        });\n    }\n    \n    showNotification(message, type = 'info', duration = 5000, actions = []) {\n        // Use the UI enhancements module if available\n        if (window.uiModule && window.uiModule.showActionNotification) {\n            if (actions.length > 0) {\n                return window.uiModule.showActionNotification(message, type, actions, duration);\n            } else {\n                return window.uiModule.showNotification(message, type, duration);\n            }\n        }\n        \n        // Fallback to browser notifications\n        if ('Notification' in window && Notification.permission === 'granted') {\n            return new Notification(message);\n        }\n        \n        console.log(`${type.toUpperCase()}: ${message}`);\n    }\n    \n    trackEvent(eventName, properties = {}) {\n        // Integration with analytics service\n        if (window.analytics && window.analytics.track) {\n            window.analytics.track(eventName, properties);\n        }\n        \n        console.log('PWA Event:', eventName, properties);\n    }\n    \n    // Clean up resources\n    destroy() {\n        this.hideInstallPrompt();\n        \n        const indicator = document.getElementById('connection-indicator');\n        if (indicator) {\n            indicator.remove();\n        }\n        \n        this.initialized = false;\n    }\n}